require 'fileutils'

class Forest
  module Default
    def default__forest_private(_node)
      # It has to be defined to make the compiler aware of it
      # and format properly format_call with private,
      # but it will never be called (context takes care for it)
    end

    # Call to "private" can be wrapped with set_value,
    # so we search for it in the whole branch
    # (we skip unless "private" embedded in other "context" nodes).
    # This function returns the block or false.
    def private_block(node)
      if (node[:command] == "call") && (node[:children][0][:children][0][:command] == "private")
        if node[:children][1][:command] == "block"
          # block
          # TODO: eliminate this option because it won't be
          # generated by lamb
          return node[:children][1][:children]
        else
          #context
          return node[:children][1][:children][1][:children]
        end
      elsif (node[:command] == "context")
        return false
      end
      node[:children].each do |child|
        result = private_block(child)
        return result if result
      end
      false
    end

    # Macro-stage keyword. It rearranges the context
    # to respect "private" keyword
    def default__forest_context(node)
      evaluate(node)
      public_nodes = []
      private_nodes = []
      node[:children].each do |child|
        privs = private_block(child)
        if privs
          private_nodes = privs
        else
          public_nodes += [child]
        end
      end
      if private_nodes == []
        node[:parent][:children][0][:children][0][:command] = "cgs.context"
        return
      end

      private_nodes_block = copy_node(node)
      private_nodes_block[:command] = "block"
      private_nodes_block[:children] = private_nodes
      private_nodes_block[:children].each do |child|
        child[:parent] = private_nodes_block
      end

      public_nodes_block = copy_node(node)
      public_nodes_block[:command] = "block"
      public_nodes_block[:children] = public_nodes
      public_nodes_block[:children].each do |child|
        child[:parent] = public_nodes_block
      end

      private_nodes_context_data_contents = copy_node(node)
      private_nodes_context_data_contents[:command] = "cgs.context"
      private_nodes_context_data = copy_node(node)
      private_nodes_context_data[:command] = "data"
      private_nodes_context_data[:children] =
        [private_nodes_context_data_contents]
      private_nodes_context_data_contents[:parent] =
        private_nodes_context_data

      private_nodes_context = copy_node(node)
      private_nodes_context[:command] = "call"
      private_nodes_context[:children] = [
        private_nodes_context_data,
        private_nodes_block
      ]
      private_nodes.each do |node|
        node[:parent] = private_nodes_context
      end

      private_nodes_last_data_contents = copy_node(node)
      private_nodes_last_data_contents[:command] = "cgs.last"
      private_nodes_last_data = copy_node(node)
      private_nodes_last_data[:command] = "data"
      private_nodes_last_data[:children] =
        [private_nodes_last_data_contents]
      private_nodes_last_data_contents[:parent] =
        private_nodes_last_data

      private_nodes_last = copy_node(node)
      private_nodes_last[:command] = "call"
      private_nodes_last[:children] = [
        private_nodes_last_data,
        private_nodes_context
      ]
      private_nodes_context[:parent] = private_nodes_last

      public_nodes_context_data_contents = copy_node(node)
      public_nodes_context_data_contents[:command] = "cgs.context"
      public_nodes_context_data = copy_node(node)
      public_nodes_context_data[:command] = "data"
      public_nodes_context_data[:children] =
        [public_nodes_context_data_contents]
      public_nodes_context_data_contents[:parent] =
        public_nodes_context_data

      public_nodes_context = copy_node(node)
      public_nodes_context[:command] = "call"
      public_nodes_context[:children] = [
        public_nodes_context_data,
        public_nodes_block
      ]
      public_nodes_context[:children].each do |child|
        child[:parent] = public_nodes_context
      end

      public_nodes_context_wrapper_data_contents = copy_node(node)
      public_nodes_context_wrapper_data_contents[:command] = "cgs.set_value"
      public_nodes_context_wrapper_data = copy_node(node)
      public_nodes_context_wrapper_data[:command] = "data"
      public_nodes_context_wrapper_data[:children] =
        [public_nodes_context_wrapper_data_contents]
      public_nodes_context_wrapper_data_contents[:parent] =
        public_nodes_context_wrapper_data

      public_nodes_context_wrapper = copy_node(node)
      public_nodes_context_wrapper[:command] = "call"
      public_nodes_context_wrapper[:children] = [
        public_nodes_context_wrapper_data,
        public_nodes_context
      ]

      private_nodes_block[:children] += [public_nodes_context_wrapper]
      public_nodes_context[:parent] = private_nodes_block

      # replace parent with private_nodes_last
      node_to_replace = node[:parent]
      node_to_replace_parent = node_to_replace[:parent]
      node_to_replace_siblings = node_to_replace_parent[:children]
      node_to_replace_id = node_to_replace_siblings.index(node_to_replace)
      node_to_replace_parent[:children][node_to_replace_id] = private_nodes_last
      private_nodes_last[:parent] = node_to_replace_parent
    end

    def default__forest_get(node)
      if (node[:command] == "data") && (node[:children][0][:command]["."])
        name = node[:children][0][:command]
        parent_id = node[:parent][:parent][:children].index(node[:parent])
        name_parts = name.split('.')
        first_part = name_parts[0]
        remaining_parts = name_parts[1..-1].reverse
        get_node = copy_node(node[:parent])
        get_node[:command] = "call"

        get_node_data = copy_node(node[:parent])
        get_node_data[:command] = "data"
        get_node_data[:parent] = get_node
        get_node_data_content = copy_node(node[:parent])
        get_node_data_content[:command] = "cgs.get"
        get_node_data[:children] = [ get_node_data_content ]
        get_node_data_content[:parent] = get_node_data

        get_node_value_data = copy_node(node[:parent])
        get_node_value_data[:command] = "data"
        get_node_value_data[:parent] = get_node
        get_node_value_data_content = copy_node(node[:parent])
        get_node_value_data_content[:command] = first_part
        get_node_value_data[:children] = [ get_node_value_data_content ]
        get_node_value_data_content[:parent] = get_node_data

        get_node[:children] = [ get_node_data, get_node_value_data ]

        current_node = get_node
        remaining_parts.each do |part|
          block = copy_node(node[:parent])
          block[:command] = "block"

          get_node_data = copy_node(node[:parent])
          get_node_data[:command] = "data"
          block[:children] = [ get_node_data, current_node ]
          get_node_data[:parent] = block
          get_node_data_content = copy_node(node[:parent])
          get_node_data_content[:command] = part
          get_node_data[:children] = [ get_node_data_content ]
          get_node_data_content[:parent] = get_node_data

          hash_get_node = copy_node(current_node)
          hash_get_node[:command] = "call"
          hash_get_node_data = copy_node(node[:parent])
          hash_get_node_data[:command] = "data"
          hash_get_node[:children] = [ hash_get_node_data, block ]
          hash_get_node_data[:parent] = hash_get_node
          hash_get_node_data_content = copy_node(node[:parent])
          hash_get_node_data_content[:command] = "data.hash_get"
          hash_get_node_data[:children] = [ hash_get_node_data_content ]
          hash_get_node_data_content[:parent] = hash_get_node_data

          current_node = hash_get_node
        end
        node[:parent][:parent][:children][parent_id] = current_node
        current_node[:parent] = node[:parent][:parent]
      else
        node[:parent][:children][0][:children][0][:command] = "cgs.get"
      end
    end

    # Macro-stage keyword. It formats the call to either a keyword call
    # or a function call, depending if the keyword is permitted
    # in the permissions list
    def default__forest_format_call(node)
      permissions = @global_options[:init][:permissions]
      all_commands = permissions.values.flatten.uniq
      command = node[:children][0][:children][0][:command]
      evaluate(node[:children][1])
      if all_commands.include?(command)
        node[:parent][:children][0][:children][0][:command] = command
        node[:parent][:children][1] = node[:children][1]
        node[:children][1][:parent] = node[:parent][:children][1]
      else
        now_with_args = copy_node(node[:parent])
        now_with_args[:command] = "data"
        now_with_args_data = copy_node(node[:parent])
        now_with_args_data[:parent] = now_with_args
        now_with_args[:children] = [now_with_args_data]
        now_with_args_data[:command] = "ln.now_with_args"

        name_node = node[:children][0]
        name = name_node[:children][0][:command]
        if name["."]
          name_parts = name.split('.')
          first_part = name_parts[0]
          remaining_parts = name_parts[1..-1].reverse
          get_node = copy_node(node[:parent])
          get_node[:command] = "call"

          get_node_data = copy_node(node[:parent])
          get_node_data[:command] = "data"
          get_node_data[:parent] = get_node
          get_node_data_content = copy_node(node[:parent])
          get_node_data_content[:command] = "cgs.get"
          get_node_data[:children] = [ get_node_data_content ]
          get_node_data_content[:parent] = get_node_data

          get_node_value_data = copy_node(node[:parent])
          get_node_value_data[:command] = "data"
          get_node_value_data[:parent] = get_node
          get_node_value_data_content = copy_node(node[:parent])
          get_node_value_data_content[:command] = first_part
          get_node_value_data[:children] = [ get_node_value_data_content ]
          get_node_value_data_content[:parent] = get_node_data

          get_node[:children] = [ get_node_data, get_node_value_data ]

          current_node = get_node
          remaining_parts.each do |part|
            block = copy_node(node[:parent])
            block[:command] = "block"

            get_node_data = copy_node(node[:parent])
            get_node_data[:command] = "data"
            block[:children] = [ get_node_data, current_node ]
            get_node_data[:parent] = block
            get_node_data_content = copy_node(node[:parent])
            get_node_data_content[:command] = part
            get_node_data[:children] = [ get_node_data_content ]
            get_node_data_content[:parent] = get_node_data

            hash_get_node = copy_node(current_node)
            hash_get_node[:command] = "call"
            hash_get_node_data = copy_node(node[:parent])
            hash_get_node_data[:command] = "data"
            hash_get_node[:children] = [ hash_get_node_data, block ]
            hash_get_node_data[:parent] = hash_get_node
            hash_get_node_data_content = copy_node(node[:parent])
            hash_get_node_data_content[:command] = "data.hash_get"
            hash_get_node_data[:children] = [ hash_get_node_data_content ]
            hash_get_node_data_content[:parent] = hash_get_node_data

            current_node = hash_get_node
          end
          name_node = current_node
        else
          get_data_value = copy_node(node[:parent], parent: node[:parent])
          get_data_value[:command] = "cgs.get"

          get_data = copy_node(node[:parent], parent: node[:parent])
          get_data[:command] = "data"
          get_data[:children] = [get_data_value]

          get_node = copy_node(node[:parent], parent: node[:parent])
          get_node[:command] = "call"
          get_node[:children] = [get_data, name_node]
          get_data[:children].each do |child|
            child[:parent] = get_node
          end

          name_node = get_node
        end
        args = node[:children][1]

        block = copy_node(node[:parent])
        block[:command] = "block"
        block[:children] = [args, name_node]
        block[:children].each do |child|
          child[:parent] = block
        end

        node[:parent][:command] = "call"
        node[:parent][:children] = [now_with_args, block]
        node[:parent][:children].each do |child|
          child[:parent] = node[:parent]
        end

        node
      end
    end

    def default__forest_integer(node)
      result = evaluate(node)
      result[0].to_i
    end

    def default__forest_or(node)
      result = evaluate(node)
      result[0] || result[1]
    end

    def default__forest_url(node)
      data = evaluate(node)[0]
      if data[/^http:\/\//]
        data
      else
        raise "Wrong IP address: '#{data}' in: #{node[:file]}:#{node[:line]}"
      end
    end

    def default__forest_envvar(node)
      variable = evaluate(node)[0]
      @global_options[:init] &&
        @global_options[:init][:env] &&
        @global_options[:init][:env][variable]
    end

    def default__forest_merge(node)
      data = evaluate(node)
      data[0].merge(data[1])
    end

    private

    def copy_node(node, to_merge = {})
      {
        line: node[:line],
        pos: node[:pos],
        file: node[:file],
        parent: node[:parent],
        children: []
      }.merge(to_merge)
    end
  end
end
