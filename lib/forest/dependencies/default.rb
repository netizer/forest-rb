require 'fileutils'

class Forest
  module Default
    def default__forest_private(_node)
      # It has to be defined to make the compiler aware of it
      # and format properly format_call with private,
      # but it will never be called (context takes care for it)
    end

    # Call to "private" can be wrapped with set_value,
    # so we search for it in the whole branch
    # (we skip unless "private" embedded in other "context" nodes).
    # This function returns the block or false.
    def private_block(node)
      if (node[:command] == "call") && (node[:children][0][:children][0][:command] == "private")
        if node[:children][1][:command] == "block"
          # block
          # TODO: eliminate this option because it won't be
          # generated by lamb
          return node[:children][1][:children]
        else
          #context
          return node[:children][1][:children][1][:children]
        end
      elsif (node[:command] == "context")
        return false
      end
      node[:children].each do |child|
        result = private_block(child)
        return result if result
      end
      false
    end

    # Macro-stage keyword. It rearranges the context
    # to respect "private" keyword
    def default__forest_context(node)
      base_node = node[:parent] # call

      evaluate(node)
      public_nodes = []
      private_nodes = []
      node[:children].each do |child|
        privs = private_block(child)
        if privs
          private_nodes = privs
        else
          public_nodes += [child]
        end
      end
      if private_nodes == []
        base_node[:children][0][:children][0][:command] = "cgs.context"
        return
      end

      private_nodes_block = add_parent("block", private_nodes, base_node)
      public_nodes_block = add_parent("block", public_nodes, base_node)

      private_nodes_context = add_call_wrapper("cgs.context",
        private_nodes_block, base_node)
      private_nodes_last = add_call_wrapper("cgs.last",
        private_nodes_context, base_node)
      public_nodes_context = add_call_wrapper("cgs.context",
        public_nodes_block, base_node)
      public_nodes_context_wrapper = add_call_wrapper("cgs.set_value",
        public_nodes_context, base_node)

      private_nodes_block[:children] += [public_nodes_context_wrapper]
      public_nodes_context_wrapper[:parent] = private_nodes_block
      replace_node(base_node, private_nodes_last)
      node
    end

    def default__forest_get(node)
      base_node = node[:parent]
      current_node = add_get_branch(node[:children][0][:command], base_node)
      replace_node(base_node, current_node)
      node
    end

    # Macro-stage keyword. It formats the call to either a keyword call
    # or a function call, depending if the keyword is permitted
    # in the permissions list
    def default__forest_format_call(node)
      base_node = node[:parent]
      permissions = @global_options[:permissions]
      all_commands = permissions.values.flatten.uniq
      command = node[:children][0][:children][0][:command]
      evaluate(node[:children][1])
      if all_commands.include?(command)
        base_node[:children][0][:children][0][:command] = command
        base_node[:children][1] = node[:children][1]
        node[:children][1][:parent] = base_node[:children][1]
      else
        args = node[:children][1]
        name = node[:children][0][:children][0][:command]
        get_node = add_get_branch(name, base_node)
        block = add_parent("block", [args, get_node], base_node)
        new_node = add_call_wrapper("ln.now_with_args",
          block, base_node)
        replace_node(base_node, new_node)
        node
      end
    end

    def default__forest_integer(node)
      result = evaluate(node)
      result[0].to_i
    end

    def default__forest_or(node)
      result = evaluate(node)
      result[0] || result[1]
    end

    def default__forest_url(node)
      data = evaluate(node)[0]
      if data[/^http:\/\//]
        data
      else
        raise "Wrong IP address: '#{data}' in: #{node[:file]}:#{node[:line]}"
      end
    end

    def default__forest_envvar(node)
      variable = evaluate(node)[0]
      @global_options &&
        @global_options[:env] &&
        @global_options[:env][variable]
    end

    def default__forest_merge(node)
      data = evaluate(node)
      data[0].merge(data[1])
    end

    private

    def copy_node(node, to_merge = {})
      {
        line: node[:line],
        pos: node[:pos],
        file: node[:file],
        parent: node[:parent],
        children: []
      }.merge(to_merge)
    end
  end
end
